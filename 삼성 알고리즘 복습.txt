#1103 게임 -> dfs + dp
- dfs에서 방문했던 지점을 다시 방문하는문제의 경우 dp를 이용하지 않으면 시간초과가 무조건 나옴.
- 해당 지점에서 한번 dfs를 한경우 그 결과를 저장해 놓아야함 (이 문제에서는 이동한 횟수를 저장)
- dfs에서 visited배열은 해당 dfs 시작하고 true로 하고 for문 다 끝나면 false로 돌림(bfs와 다름)

#1806 부분합 -> 투포인터
- 구간을 차례대로 변화시켜가면서 부분합을 구하는것 -> 투포인터를 이용
- 하나의 배열에서 여러 구간을 확인함 - l,r = 0으로 잡고 출발
- 하나 이상의 배열에서 두 수의 합이 특정 수에 가까워 지는경우 - 정렬 후 l = 0 r = size()-1로 잡고 출발

#2042 인덱스트리
- n보다 큰 PIV(2의 제곱수)를 잡고 1~PIV-1 = 부모, PIV~ 2 * PIV -1 = 리프노드로 잡기
- update시 부모들 싹 변경해주기
- query시 l = x + PIV -1, r = y + PIV-1 하고 l % 2== 1, r %2 == 0으로 조건잡고 돌리기.

#2517 달리기
- 게속 한명씩 추가해 가면서 자신보다 숫자가 높은 원소가 있는지 확인함 ->카운팅 인덱스 트리로품
- 좌표가 매우 큰 경우 tree의 한계가 있으므로 map을 이용해서 좌표압축을 해야함.

#2243 사탕찾기
- 인덱스트리를 이용한 순위찾기 문제
- 순위찾는것은 위에서부터 시작함 -> 왼쪽 자식, 오른쪽 자식을 비교해서 왼쪽자식이(왼쪽에 있는 노드들의 합) 원하는 순위보다 크면 그냥 왼쪽 자식으로, 왼쪽 자식이 원하는 순위보다 작으면 오른쪽 자식으로 넘어가고 왼쪽 자식의 값을 순위에서 뺌.
- 위 과정을 리프노드에 올떄까지 반복.

#1202 보석도둑
- 보석을 가격높은순으로 정렬하고 그에 알맞은 가방을 찾아나가는 방식으로 풀었다가 시간초과가 났었음.
- 가방은 자신보다 작은 모든 수를 받을수 있기때문에 작은 가방에 들어가는 보석은 큰 가방에도 들어가는 아이디어를 생각해내는 것이 필요했음.


7578,12015,14003,1256

